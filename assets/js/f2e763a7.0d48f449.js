"use strict";(self.webpackChunksquirrels_docs=self.webpackChunksquirrels_docs||[]).push([[9070],{2806:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"docs/concepts/models-source","title":"Sources","description":"Sources in Squirrels connect your project to external data sources such as databases, APIs, or files. They define how data is extracted from these sources and loaded into your project\'s DuckDB environment.","source":"@site/docs/docs/concepts/models-source.md","sourceDirName":"docs/concepts","slug":"/docs/concepts/models-source","permalink":"/docs/docs/concepts/models-source","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Data Models","permalink":"/docs/docs/concepts/models"},"next":{"title":"Seeds","permalink":"/docs/docs/concepts/models-seed"}}');var i=s(4848),l=s(8453);const o={},t="Sources",d={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Key Properties",id:"key-properties",level:2},{value:"Basic Configuration",id:"basic-configuration",level:3},{value:"Keys and Incremental Loading",id:"keys-and-incremental-loading",level:3},{value:"Column Definitions",id:"column-definitions",level:3},{value:"Usage",id:"usage",level:2},{value:"In Dbview Models",id:"in-dbview-models",level:3},{value:"In Other Models",id:"in-other-models",level:3},{value:"Incremental Loading Patterns",id:"incremental-loading-patterns",level:2},{value:"Always Full Refresh",id:"always-full-refresh",level:3},{value:"Strictly Increasing Values",id:"strictly-increasing-values",level:3},{value:"Timestamps with Possible Updates",id:"timestamps-with-possible-updates",level:3},{value:"Selective Overwrite",id:"selective-overwrite",level:3},{value:"Loading to the Virtual Data Environment",id:"loading-to-the-virtual-data-environment",level:2},{value:"Best Practices",id:"best-practices",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"sources",children:"Sources"})}),"\n",(0,i.jsx)(n.p,{children:"Sources in Squirrels connect your project to external data sources such as databases, APIs, or files. They define how data is extracted from these sources and loaded into your project's DuckDB environment."}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["Sources are defined in the ",(0,i.jsx)(n.code,{children:"models/sources.yml"})," file. Here's an example configuration:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'sources:\n  - name: src_transactions\n    description: "The source table for transactions"\n    connection: default           # connection name from connections.yml\n    table: expenses               # table name in the source database\n    load_to_duckdb: true          # load data into DuckDB / virtual data environment\n    primary_key: [id]             # column(s) for upserts\n    \n    update_hints:\n      increasing_column: date     # column to track incremental updates\n      strictly_increasing: false  # whether max value should be deleted during incremental loads\n\n    columns:                      # columns to load (if empty, all columns are loaded)\n      - name: id\n        type: string\n        description: The unique identifier for the transaction\n        category: dimension\n\n      - name: date\n        type: date\n        description: The date of the transaction\n        category: dimension\n\n      - name: amount\n        type: float\n        description: The amount of the transaction\n        category: measure\n'})}),"\n",(0,i.jsx)(n.h2,{id:"key-properties",children:"Key Properties"}),"\n",(0,i.jsx)(n.h3,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"}),": A unique identifier for the source model"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"description"}),": A human-readable description of the source model"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"connection"}),": The connection name as defined in your connections.yml file"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"table"}),": The table or view name in the source database (defaults to the source name if not provided)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"load_to_duckdb"}),": Whether to load the data into DuckDB (required for models other than dbview models to reference this source)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"connection"})," is not specified, the source will be loaded from the default connection (usually ",(0,i.jsx)(n.code,{children:"default"}),") specified with the ",(0,i.jsx)(n.a,{href:"./environment",children:"environment variable"})," ",(0,i.jsx)(n.code,{children:"SQRL_CONNECTIONS__DEFAULT_NAME_USED"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"important",children:(0,i.jsxs)(n.p,{children:["Currently, setting ",(0,i.jsx)(n.code,{children:"load_to_duckdb"})," to true is only supported if the connection uses ",(0,i.jsx)(n.code,{children:"sqlite"}),", ",(0,i.jsx)(n.code,{children:"postgres"}),", and ",(0,i.jsx)(n.code,{children:"mysql"}),". Support for additional dialects will be included in future releases. ",(0,i.jsx)(n.strong,{children:"Do not set this to true for other dialects!"})]})}),"\n",(0,i.jsx)(n.h3,{id:"keys-and-incremental-loading",children:"Keys and Incremental Loading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"primary_key"}),": Columns that uniquely identify a record, used for upserts during incremental loads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"update_hints"}),": Configuration for incremental loading","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"increasing_column"}),": Column used to identify new or changed records (e.g., timestamp, ID)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"strictly_increasing"}),": Whether values in the increasing_column only increase (true) or can also change (false)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"selective_overwrite_value"}),": Specific value to use for deleting records before incremental load"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"increasing_column"})," is not specified, the source model will always do a full refresh during builds. When specified, it enables incremental loading, which only fetches new or changed records since the last build."]}),"\n",(0,i.jsx)(n.h3,{id:"column-definitions",children:"Column Definitions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"columns"}),": Definitions of columns to load from the source","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"}),": Column name in the source"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"type"}),": Data type for the column. See the ",(0,i.jsx)(n.a,{href:"./column-types",children:"Column Types"})," documentation for supported types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"description"}),": Human-readable description of the column"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"category"}),": Category of the column (dimension, measure, misc)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"load_to_duckdb"})," is set to ",(0,i.jsx)(n.code,{children:"true"})," and no columns are specified, all columns from the source table will be loaded. When columns are specified, only those columns with their specified types will be loaded into the virtual data environment."]}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:"Sources serve as the foundation of your data pipeline and are referenced by other models."}),"\n",(0,i.jsx)(n.h3,{id:"in-dbview-models",children:"In Dbview Models"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"./models-dbview",children:"Dbview models"})," can reference source models using the ",(0,i.jsx)(n.code,{children:"source()"})," macro:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'-- In a dbview model\nSELECT \n    date,\n    amount\nFROM {{ source("src_transactions") }}\nWHERE amount > 100\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If the dbview model has ",(0,i.jsx)(n.code,{children:"translate_to_duckdb: true"}),", then the dbview model can only depend on sources that have ",(0,i.jsx)(n.code,{children:"load_to_duckdb: true"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"in-other-models",children:"In Other Models"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"./models-build",children:"Build models"})," and ",(0,i.jsx)(n.a,{href:"./models-federate",children:"federate models"})," can reference source models using the ",(0,i.jsx)(n.code,{children:"ref()"})," function, but only if ",(0,i.jsx)(n.code,{children:"load_to_duckdb"})," is set to ",(0,i.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'-- In a build or federate SQL model\nSELECT \n    date,\n    amount\nFROM {{ ref("src_transactions") }}\nWHERE amount > 100\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# In a Python model\ndef model(sqrl):\n    df = sqrl.ref("src_transactions")\n    return df.filter(pl.col("amount") > 100)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"incremental-loading-patterns",children:"Incremental Loading Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"always-full-refresh",children:"Always Full Refresh"}),"\n",(0,i.jsxs)(n.p,{children:["When a source model doesn't specify an ",(0,i.jsx)(n.code,{children:"increasing_column"}),", it will perform a full refresh during each build:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"sources:\n  - name: src_small_lookup_table\n    connection: default\n    table: lookup_table\n    load_to_duckdb: true\n    # No increasing_column = full refresh every time\n"})}),"\n",(0,i.jsx)(n.h3,{id:"strictly-increasing-values",children:"Strictly Increasing Values"}),"\n",(0,i.jsx)(n.p,{children:"For columns with values that only increase (like auto-incrementing IDs):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"sources:\n  - name: src_orders\n    connection: default\n    table: orders\n    load_to_duckdb: true\n    primary_key: [order_id]\n    update_hints:\n      increasing_column: order_id\n      strictly_increasing: true\n"})}),"\n",(0,i.jsx)(n.h3,{id:"timestamps-with-possible-updates",children:"Timestamps with Possible Updates"}),"\n",(0,i.jsx)(n.p,{children:"For timestamps where records might be updated:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"sources:\n  - name: src_customers\n    connection: default\n    table: customers\n    load_to_duckdb: true\n    primary_key: [customer_id]\n    update_hints:\n      increasing_column: updated_at\n      strictly_increasing: false  # Max timestamp will be removed before load\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It is important to set ",(0,i.jsx)(n.code,{children:"strictly_increasing"})," to ",(0,i.jsx)(n.code,{children:"false"})," in this example if it's possible for records to have the same value ",(0,i.jsx)(n.code,{children:"updated_at"}),". And by defining the primary key, you ensure that records that pre-existed in Duckdb will be replaced with an updated value for ",(0,i.jsx)(n.code,{children:"updated_at"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"selective-overwrite",children:"Selective Overwrite"}),"\n",(0,i.jsx)(n.p,{children:"For cases where you want to overwrite records from a specific date forward:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'sources:\n  - name: src_daily_metrics\n    connection: default\n    table: metrics\n    load_to_duckdb: true\n    update_hints:\n      increasing_column: date\n      selective_overwrite_value: "2023-01-01"  # All records >= this date will be deleted before load\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["In a future version of Squirrels, we may provide a more elegant way to specify selective overwrite values by providing arguments to the ",(0,i.jsx)(n.a,{href:"../../references/cli/build",children:"sqrl build"})," command or the ",(0,i.jsx)(n.code,{children:"/build"})," API endpoint."]})}),"\n",(0,i.jsx)(n.h2,{id:"loading-to-the-virtual-data-environment",children:"Loading to the Virtual Data Environment"}),"\n",(0,i.jsxs)(n.p,{children:["Sources that have ",(0,i.jsx)(n.code,{children:"load_to_duckdb: true"})," will be loaded into the virtual data environment when running ",(0,i.jsx)(n.a,{href:"../../references/cli/build",children:"sqrl build"}),". This command has a ",(0,i.jsx)(n.code,{children:"--full-refresh"})," or",(0,i.jsx)(n.code,{children:"-f"})," flag that can be used to force a full refresh of the source. If running ",(0,i.jsx)(n.a,{href:"../../references/cli/run",children:"sqrl run"})," with the ",(0,i.jsx)(n.code,{children:"--build"})," flag, this would always build with a full refresh before activating the API server."]}),"\n",(0,i.jsxs)(n.p,{children:["It is recommended to perform a full refresh if the following changes are made to a source that has ",(0,i.jsx)(n.code,{children:"load_to_duckdb: true"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A column is added or removed"}),"\n",(0,i.jsx)(n.li,{children:"A column name or type is changed"}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["In a future version of Squirrels, we may automatically detect these changes and perform a full refresh of the sources with these changes, and their downstream build models, without having to specify the ",(0,i.jsx)(n.code,{children:"--full-refresh"})," flag and perform a full refresh for the entire project."]})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use load_to_duckdb strategically"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Set ",(0,i.jsx)(n.code,{children:"load_to_duckdb: true"})," for tables that need to be referenced by multiple models or for smaller datasets"]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"load_to_duckdb: false"})," for large tables that are only used in dbview models"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Define column types explicitly"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always specify column types to ensure proper type handling"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use primary keys for updatable sources"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Define primary keys for tables where records might be updated"}),"\n",(0,i.jsx)(n.li,{children:"This enables proper upsert behavior during incremental loads"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose the right incremental loading pattern"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use timestamps for tables that have records that can be updated"}),"\n",(0,i.jsx)(n.li,{children:"Use auto-incrementing IDs for append-only tables"}),"\n",(0,i.jsx)(n.li,{children:"Consider full refresh for small lookup tables"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Document your sources"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Add clear descriptions to sources and columns"}),"\n",(0,i.jsx)(n.li,{children:"Categorize columns properly (dimension, measure, misc)"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>t});var r=s(6540);const i={},l=r.createContext(i);function o(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);