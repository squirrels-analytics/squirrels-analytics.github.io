"use strict";(self.webpackChunksquirrels_docs=self.webpackChunksquirrels_docs||[]).push([[8731],{2519:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"docs/concepts/models-build","title":"Build Models","description":"Build models in Squirrels are materialized during the build process, creating tables or views in the DuckDB environment. They support both SQL and Python transformations and are designed for more complex data manipulations that need to be persisted for downstream use.","source":"@site/docs/docs/concepts/models-build.md","sourceDirName":"docs/concepts","slug":"/docs/concepts/models-build","permalink":"/docs/docs/concepts/models-build","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Seeds","permalink":"/docs/docs/concepts/models-seed"},"next":{"title":"Dbview Models","permalink":"/docs/docs/concepts/models-dbview"}}');var r=s(4848),l=s(8453);const o={},t="Build Models",d={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Key Properties",id:"key-properties",level:2},{value:"How Build Models Work",id:"how-build-models-work",level:2},{value:"Pass-Through Columns",id:"pass-through-columns",level:2},{value:"Usage",id:"usage",level:2},{value:"Loading to the Virtual Data Environment",id:"loading-to-the-virtual-data-environment",level:2},{value:"Best Practices",id:"best-practices",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"build-models",children:"Build Models"})}),"\n",(0,r.jsx)(n.p,{children:"Build models in Squirrels are materialized during the build process, creating tables or views in the DuckDB environment. They support both SQL and Python transformations and are designed for more complex data manipulations that need to be persisted for downstream use."}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Build models consist of two files:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"A SQL or Python file with the transformation logic"}),"\n",(0,r.jsx)(n.li,{children:"A YAML file with metadata"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example SQL file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'SELECT\n    t.id,\n    t.date::TEXT AS date,\n    DATE_TRUNC(\'month\', t.date)::TEXT AS month,\n    c.category_id,\n    c.category,\n    sc.subcategory_id,\n    sc.subcategory,\n    t.amount,\n    t.description\nFROM {{ ref("src_transactions") }} t\nLEFT JOIN {{ ref("seed_categories") }} c\n    ON t.category_id = c.category_id\nLEFT JOIN {{ ref("seed_subcategories") }} sc\n    ON t.subcategory_id = sc.subcategory_id\n'})}),"\n",(0,r.jsx)(n.p,{children:"Example Python file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def model(sqrl):\n    # Load dependencies using ref()\n    transactions = sqrl.ref("src_transactions")\n    categories = sqrl.ref("seed_categories")\n    subcategories = sqrl.ref("seed_subcategories")\n    \n    # Join datasets\n    result = (\n        transactions.join(\n            categories,\n            on=transactions["category_id"] == categories["category_id"],\n            how="left"\n        )\n        .join(\n            subcategories,\n            on=transactions["subcategory_id"] == subcategories["subcategory_id"],\n            how="left"\n        )\n    )\n    \n    # Add month column\n    result = result.with_columns(\n        pl.col("date").dt.truncate("1mo").cast(pl.Utf8).alias("month")\n    )\n    \n    return result  # Return a Polars LazyFrame\n'})}),"\n",(0,r.jsx)(n.p,{children:"Example YAML file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'description: |\n  This is an example of a build model. It adds a new column called "month" to the source table "src_transactions".\n\nmaterialization: TABLE  # Optional - defaults to "VIEW" for SQL models, always "TABLE" for Python models\n\ndepends_on:  # List of upstream dependencies, required for Python models\n  - src_transactions\n  - seed_categories\n  - seed_subcategories\n\ncolumns:\n  - name: id\n    depends_on:\n      - src_transactions.id\n    pass_through: true  # Inherit metadata from upstream column\n\n  - name: date\n    type: string\n    description: The day of the transaction as a string in \'YYYY-MM-DD\' format\n    depends_on:\n      - src_transactions.date\n\n  - name: month\n    type: string\n    description: The month of the transaction as a string in \'YYYY-MM\' format\n    depends_on:\n      - src_transactions.date\n'})}),"\n",(0,r.jsx)(n.h2,{id:"key-properties",children:"Key Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"description"}),": A human-readable description of the build model"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"materialization"}),": The materialization type (TABLE or VIEW)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Default is "VIEW" for SQL models'}),"\n",(0,r.jsx)(n.li,{children:'Python models are always materialized as "TABLE"'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"depends_on"}),": List of models this model depends on (automatically populated for SQL models when using ",(0,r.jsx)(n.code,{children:"ref()"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"columns"}),": Definitions of columns produced by the model","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"}),": Column name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"type"}),": Data type for the column. This is metadata exposed through API endpoints, and not enforced if the query produces a different type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"description"}),": Human-readable description of the column"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"category"}),": Category of the column (dimension, measure, misc)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"depends_on"}),": List of upstream columns this column depends on"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pass_through"}),": Whether this column is passed through from an upstream model (boolean)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"how-build-models-work",children:"How Build Models Work"}),"\n",(0,r.jsx)(n.p,{children:"Build models are processed in a specific sequence during the build process:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependency Resolution"}),": Squirrels constructs a directed acyclic graph (DAG) of all models to determine the correct build order."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compilation"}),": For each build model:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["SQL models: The template is rendered with Jinja, resolving all ",(0,r.jsx)(n.code,{children:"ref()"})," calls"]}),"\n",(0,r.jsx)(n.li,{children:"Python models: The function is prepared for execution with the appropriate arguments"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Execution"}),": Models are executed according to their dependency order:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"SQL models: The compiled SQL is executed to create a table or view"}),"\n",(0,r.jsx)(n.li,{children:"Python models: The Python function is executed, and the resulting dataframe is materialized as a table"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Materialization"}),": The results are stored in DuckDB / the virtual data environment."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Build models can depend on ",(0,r.jsx)(n.a,{href:"./models-source",children:"sources"})," (with ",(0,r.jsx)(n.code,{children:"load_to_duckdb: true"}),"), ",(0,r.jsx)(n.a,{href:"./models-seed",children:"seeds"}),", or other build models."]}),"\n",(0,r.jsx)(n.h2,{id:"pass-through-columns",children:"Pass-Through Columns"}),"\n",(0,r.jsx)(n.p,{children:'Build models support "pass-through" columns, which inherit metadata from upstream columns. This is useful for:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Preserving column descriptions and metadata through transformations"}),"\n",(0,r.jsx)(n.li,{children:"Ensuring consistent metadata across models"}),"\n",(0,r.jsx)(n.li,{children:"Reducing redundancy in YAML configurations"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When a column is defined with ",(0,r.jsx)(n.code,{children:"pass_through: true"}),", it must have exactly one dependency in ",(0,r.jsx)(n.code,{children:"depends_on"}),". Unless explicitly overridden, the column inherits:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Type"}),"\n",(0,r.jsx)(n.li,{children:"Description"}),"\n",(0,r.jsx)(n.li,{children:"Category"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:["Build models can be referenced by ",(0,r.jsx)(n.a,{href:"./models-federate",children:"federate models"})," and other build models using the ",(0,r.jsx)(n.code,{children:"ref()"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'-- In another SQL model\nSELECT * FROM {{ ref("build_example") }}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# In a Python model\ndef model(args):\n    df = args.ref("build_example")\n    return df\n'})}),"\n",(0,r.jsx)(n.h2,{id:"loading-to-the-virtual-data-environment",children:"Loading to the Virtual Data Environment"}),"\n",(0,r.jsxs)(n.p,{children:["By default, all build models are recreated during each build process with ",(0,r.jsx)(n.a,{href:"../../references/cli/build",children:"sqrl build"}),". However, if a partial build is performed by specifying which models to build:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"sqrl build --select build_example\n"})}),"\n",(0,r.jsx)(n.p,{children:"Only the specified models and their downstream dependencies will be rebuilt."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Currently, incremental loading is not supported for build models. This will be supported in a future version of Squirrels."})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Choose the right materialization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use TABLE for frequently accessed models or when performance is critical"}),"\n",(0,r.jsx)(n.li,{children:"Use VIEW for models that don't need materialization or are accessed infrequently"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure complex transformations as build models"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Build models allow you to pre-compute complex joins and transformations"}),"\n",(0,r.jsx)(n.li,{children:"This improves performance for downstream models"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Python for complex logic"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When SQL becomes too complex, consider using Python"}),"\n",(0,r.jsx)(n.li,{children:"Python models provide access to the full Polars/Pandas API for advanced operations"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Define columns completely"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Document all columns with types, descriptions, and categories"}),"\n",(0,r.jsx)(n.li,{children:"Use pass-through columns to inherit metadata when appropriate"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consider dependency management"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Explicitly list all dependencies in the YAML file"}),"\n",(0,r.jsxs)(n.li,{children:["Although SQL models automatically track dependencies through ",(0,r.jsx)(n.code,{children:"ref()"})," calls, it is recommended to explicitly list dependencies in the YAML file"]}),"\n",(0,r.jsx)(n.li,{children:"Python models require explicit dependency declarations"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>t});var i=s(6540);const r={},l=i.createContext(r);function o(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);