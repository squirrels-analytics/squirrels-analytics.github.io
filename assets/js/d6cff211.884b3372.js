"use strict";(self.webpackChunksquirrels_docs=self.webpackChunksquirrels_docs||[]).push([[5492],{8001:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var r=t(5674),s=t(74848),i=t(28453);const a={slug:"1brc-postgres",title:"Query 1B Rows in PostgreSQL >25x Faster with Squirrels!",authors:"thuang",tags:["squirrels","postgresql","duckdb","performance"]},l=void 0,o={authorsImageUrls:[void 0]},c=[{value:"The Challenge",id:"the-challenge",level:2},{value:"Setting Up the Environment",id:"setting-up-the-environment",level:2},{value:"Data Generation and Loading",id:"data-generation-and-loading",level:2},{value:"Initial Query Performance",id:"initial-query-performance",level:2},{value:"Enter Squirrels",id:"enter-squirrels",level:2},{value:"Performance Results",id:"performance-results",level:2},{value:"Handling Data Updates",id:"handling-data-updates",level:2},{value:"Behind the Scenes of the &quot;Data Artifact&quot;",id:"behind-the-scenes-of-the-data-artifact",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://www.morling.dev/blog/one-billion-row-challenge/",children:"One Billion Row Challenge"})," has been making waves in the data engineering community lately. Originally created to test CSV parsing performance, the challenge involves processing a file containing 1 billion weather measurements to calculate basic temperature statistics for each city. In this post, I'll tackle a variation of this challenge using PostgreSQL and demonstrate how to achieve dramatic performance improvements using Squirrels."]}),"\n",(0,s.jsx)(n.h2,{id:"the-challenge",children:"The Challenge"}),"\n",(0,s.jsxs)(n.p,{children:["The original ",(0,s.jsx)(n.a,{href:"https://www.morling.dev/blog/one-billion-row-challenge/",children:"One Billion Row Challenge"})," focuses on raw CSV processing performance. For our variation, we'll:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Load 1 billion rows into PostgreSQL with additional columns"}),"\n",(0,s.jsx)(n.li,{children:"Query for city-level temperature statistics"}),"\n",(0,s.jsx)(n.li,{children:"Create a Squirrels project to serve these analytics via REST API"}),"\n",(0,s.jsx)(n.li,{children:"Demonstrate significant query performance improvements"}),"\n",(0,s.jsx)(n.li,{children:"Show how to handle incremental data updates"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-the-environment",children:"Setting Up the Environment"}),"\n",(0,s.jsx)(n.p,{children:"I provisioned the following AWS resources in the same region and availability zone:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"An RDS PostgreSQL database (db.r6g.large: 2 vCPUs, 16GB RAM)"}),"\n",(0,s.jsx)(n.li,{children:"An EC2 instance (r8g.large: 2 vCPUs, 16GB RAM)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"data-generation-and-loading",children:"Data Generation and Loading"}),"\n",(0,s.jsxs)(n.p,{children:["I generated a 24GB CSV file containing 1 billion weather measurements using a modified version of the createMeasurements.py script from ",(0,s.jsx)(n.a,{href:"https://github.com/ifnesi/1brc",children:"this github repo"}),". The first few lines of the file look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Bissau;2012-02-20;14.3\nAlmaty;2019-10-24;-5.3\nAnkara;2012-10-27;-6.7\nHouston;2010-06-08;10.6\nMakassar;2012-04-29;36.0\n"})}),"\n",(0,s.jsx)(n.p,{children:"The data was loaded into a simple PostgreSQL table with the following DDL:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE weather_data (\n    id SERIAL PRIMARY KEY,\n    city VARCHAR(100),\n    recorded_date DATE,\n    temperature FLOAT\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"This created a 73GB PostgreSQL table with 4 columns and 1 billion rows."}),"\n",(0,s.jsx)(n.h2,{id:"initial-query-performance",children:"Initial Query Performance"}),"\n",(0,s.jsx)(n.p,{children:"Our baseline query to calculate city-level statistics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT city, MIN(temperature), MAX(temperature), AVG(temperature) \nFROM weather_data \nGROUP BY city\nORDER BY city;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This query took approximately 7 minutes to complete against the PostgreSQL table."}),"\n",(0,s.jsx)(n.h2,{id:"enter-squirrels",children:"Enter Squirrels"}),"\n",(0,s.jsx)(n.p,{children:"I created a Squirrels project to serve these analytics via a REST API. The project structure looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"sqrl-1brc-postgres/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 dbviews/\n\u2502   \u2502   \u251c\u2500\u2500 aggregate_weather.sql\n\u2502   \u2502   \u2514\u2500\u2500 aggregate_weather.yml\n\u2502   \u2514\u2500\u2500 sources.yml\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 env.yml\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 squirrels.yml\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The query (found in ",(0,s.jsx)(n.code,{children:"models/dbviews/aggregate_weather.sql"}),") was slightly modified to use Squirrels' source macro:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'SELECT city, MIN(temperature), MAX(temperature), AVG(temperature) \nFROM {{ source("src_weather_data") }}\nGROUP BY city\nORDER BY city;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"models/sources.yml"}),' file is used to tell Squirrels details about the source named "src_weather_data" including metadata about the table and columns.']}),"\n",(0,s.jsxs)(n.p,{children:["The full Squirrels project can be found on GitHub ",(0,s.jsx)(n.a,{href:"https://github.com/squirrels-analytics/squirrels-examples/tree/main/sqrl-1brc-postgres",children:"here"}),". This includes all files except for the env.yml file which looks something like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"env_vars:\n  postgres_uri: postgresql://postgres:********@postgres-db.************.us-east-1.rds.amazonaws.com:5432/postgres\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The project dependencies were installed using ",(0,s.jsx)(n.code,{children:"pip install -r requirements.txt"}),". This also installs the ",(0,s.jsx)(n.code,{children:"sqrl"})," CLI tool for commands such as running the API server and building the data artifact."]}),"\n",(0,s.jsxs)(n.p,{children:["After running ",(0,s.jsx)(n.code,{children:"sqrl run --host 0.0.0.0 --no-cache"})," to start the API server, the REST API can be accessed with GET method at the endpoint:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"/squirrels-v0/1brc-postgres/v1/dataset/aggregate-weather"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["First, I ran the API request without building the data artifact to get the baseline query performance. Then, I ran ",(0,s.jsx)(n.code,{children:"sqrl build --stage"})," to build the necessary data artifact to improve query performance, and ran the API request again. The data artifact is stored in the ",(0,s.jsx)(n.code,{children:"target/"})," folder and is about 5GB in size."]}),"\n",(0,s.jsx)(n.h2,{id:"performance-results",children:"Performance Results"}),"\n",(0,s.jsx)(n.p,{children:"The following are the performance results:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Initial API Request: 419.51 seconds (\u22487 minutes)"}),"\n",(0,s.jsxs)(n.li,{children:["Running ",(0,s.jsx)(n.code,{children:"sqrl build --stage"}),": 434.19 seconds"]}),"\n",(0,s.jsxs)(n.li,{children:["API request after running the build: ",(0,s.jsx)(n.strong,{children:"15.93 seconds"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"We successfully reduced the query runtime from 7 minutes to 15.93 seconds, a 26x performance improvement!"})}),"\n",(0,s.jsx)(n.h2,{id:"handling-data-updates",children:"Handling Data Updates"}),"\n",(0,s.jsxs)(n.p,{children:["Squirrels makes it easy to handle incremental updates through update hints in ",(0,s.jsx)(n.code,{children:"sources.yml"})," (notice the ",(0,s.jsx)(n.code,{children:"update_hints"})," section below):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"sources:\n  - name: src_weather_data\n    description: A table containing weather data\n    table: weather_data\n    update_hints:\n      increasing_column: id\n    columns: ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"To test this, I:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Added 1 million new rows to the PostgreSQL table"}),"\n",(0,s.jsxs)(n.li,{children:["Ran ",(0,s.jsx)(n.code,{children:"sqrl build --stage"})," (took 41.84 seconds) and confirmed that the data artifact was updated"]}),"\n",(0,s.jsxs)(n.li,{children:["Tested query performance (took ",(0,s.jsx)(n.strong,{children:"15.66 seconds"})," for 1.001 billion rows, similar to the 15.93 seconds for 1 billion rows)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"--stage"})," flag ensures zero downtime during updates by staging the development copy before swapping the data artifact once it's not in use by any ongoing queries. In addition, the ",(0,s.jsx)(n.code,{children:"sqrl build"})," command can be run in the background at some time interval (e.g. every 10 minutes or every hour depending on data freshness requirements) to keep the data artifact up to date."]}),"\n",(0,s.jsx)(n.h2,{id:"behind-the-scenes-of-the-data-artifact",children:'Behind the Scenes of the "Data Artifact"'}),"\n",(0,s.jsxs)(n.p,{children:['The "data artifact" is actually a ',(0,s.jsx)(n.a,{href:"https://duckdb.org/",children:"DuckDB"})," database file. The ",(0,s.jsx)(n.code,{children:"sqrl build"})," command is able to build the source table(s) as DuckDB table(s) if the source table are from PostgreSQL, MySQL, or SQLite. When running an API request, Squirrels will determine whether all the necessary source tables exist in the DuckDB database for PostgreSQL, MySQL, or SQLite queries. If they do, it will translate the SQL query into DuckDB's SQL dialect (using ",(0,s.jsx)(n.a,{href:"https://sqlglot.com/sqlglot.html",children:"SQLGlot"}),") and run the query on the DuckDB file instead. Support for loading from additional sources (e.g. APIs, S3, etc.) with ",(0,s.jsx)(n.code,{children:"sqrl build"})," will be made available in the future."]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Using Squirrels together with DuckDB, we achieved:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"26x faster query performance"})," on 1 billion rows without changing the PostgreSQL query"]}),"\n",(0,s.jsx)(n.li,{children:"Simple incremental updates with zero-downtime refreshes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"While it is possible to optimize the PostgreSQL table for better performance, it often requires significant time and effort with only modest gains. In contrast, using Squirrels can achieve substantial performance improvements with minimal effort."}),"\n",(0,s.jsx)(n.p,{children:"In Part 2, we'll explore dynamic parameterized queries that change based on user input for date ranges, and demonstrate how to join results from multiple databases and unstructured data from S3 in a single API request!"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},5674:e=>{e.exports=JSON.parse('{"permalink":"/blog/1brc-postgres","source":"@site/blog/2024-12-09-1brc-postgres.md","title":"Query 1B Rows in PostgreSQL >25x Faster with Squirrels!","description":"The One Billion Row Challenge has been making waves in the data engineering community lately. Originally created to test CSV parsing performance, the challenge involves processing a file containing 1 billion weather measurements to calculate basic temperature statistics for each city. In this post, I\'ll tackle a variation of this challenge using PostgreSQL and demonstrate how to achieve dramatic performance improvements using Squirrels.","date":"2024-12-09T00:00:00.000Z","tags":[{"inline":true,"label":"squirrels","permalink":"/blog/tags/squirrels"},{"inline":true,"label":"postgresql","permalink":"/blog/tags/postgresql"},{"inline":true,"label":"duckdb","permalink":"/blog/tags/duckdb"},{"inline":true,"label":"performance","permalink":"/blog/tags/performance"}],"readingTime":4.715,"hasTruncateMarker":true,"authors":[{"name":"Tim Huang","title":"Co-Founder of Squirrels Analytics","url":"https://github.com/ty2huang","imageURL":"https://github.com/ty2huang.png","key":"thuang","page":null}],"frontMatter":{"slug":"1brc-postgres","title":"Query 1B Rows in PostgreSQL >25x Faster with Squirrels!","authors":"thuang","tags":["squirrels","postgresql","duckdb","performance"]},"unlisted":false,"nextItem":{"title":"Squirrels - What Problems Does It Solve?","permalink":"/blog/problems-solved"}}')}}]);