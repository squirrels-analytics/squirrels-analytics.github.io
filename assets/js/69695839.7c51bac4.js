"use strict";(self.webpackChunksquirrels_docs=self.webpackChunksquirrels_docs||[]).push([[7668],{27247:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"references/python/dateutils/DateModPipeline","title":"DateModPipeline","description":"The class to chain together a series of date modifier classes into a pipeline where the pipeline can be used to apply multiple modifications to an input date. A date modifier class is any class in squirrels.dateutils that starts with \\"DayIdxOf\\", \\"Offset\\", or \\"DateModPipeline\\".","source":"@site/docs/references/python/dateutils/DateModPipeline.md","sourceDirName":"references/python/dateutils","slug":"/references/python/dateutils/DateModPipeline","permalink":"/docs/next/references/python/dateutils/DateModPipeline","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"references","previous":{"title":"OffsetDays","permalink":"/docs/next/references/python/dateutils/OffsetDays"},"next":{"title":"DateStringModifier","permalink":"/docs/next/references/python/dateutils/DateStringModifier"}}');var s=n(74848),r=n(28453);const d={},o="DateModPipeline",a={},l=[{value:"Constructor",id:"constructor",level:3},{value:"Methods",id:"methods",level:2},{value:"modify",id:"modify",level:3},{value:"with_more_modifiers",id:"with_more_modifiers",level:3},{value:"get_date_list",id:"get_date_list",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"datemodpipeline",children:"DateModPipeline"})}),"\n",(0,s.jsx)(t.p,{children:'The class to chain together a series of date modifier classes into a pipeline where the pipeline can be used to apply multiple modifications to an input date. A date modifier class is any class in squirrels.dateutils that starts with "DayIdxOf", "Offset", or "DateModPipeline".'}),"\n",(0,s.jsxs)(t.p,{children:["Can be found in the classpath ",(0,s.jsx)(t.code,{children:"squirrels.dateutils.DateModPipeline"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsx)(t.p,{children:"Creates a DateModPipeline object."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Required Arguments:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"date_modifiers"}),": A sequence of date modifier objects"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.h3,{id:"modify",children:"modify"}),"\n",(0,s.jsx)(t.p,{children:"Modify an input date by applying the series of date modifiers"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Required Arguments:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"date"}),": A datetime.date object representing the input date to modify"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns:"})," The modified output date as a datetime.date object"]}),"\n",(0,s.jsx)(t.h3,{id:"with_more_modifiers",children:"with_more_modifiers"}),"\n",(0,s.jsx)(t.p,{children:"Create a new DateModPipeline with more date modifiers"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Required Arguments:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"date_modifiers"}),": A sequence of date modifier objects to add"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns:"})," A new DateModPipeline object"]}),"\n",(0,s.jsx)(t.h3,{id:"get_date_list",children:"get_date_list"}),"\n",(0,s.jsx)(t.p,{children:"This method modifies the input date, and returns all dates from the input date to the modified date,\nincremented by a DateModifier step"}),"\n",(0,s.jsx)(t.p,{children:"If the step is positive and start date is less than end date, then it'll return an increasing list of\ndates starting from the start date. If the step is negative and start date is greater than end date,\nthen it'll return a decreasing list of dates starting from the start date. Otherwise, an empty list\nis returned"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Required Arguments:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"start_date"}),": A datetime.date object for the start date"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"step"}),": An ",(0,s.jsx)(t.a,{href:"./OffsetUnits",children:"_OffsetUnits"})," object for the increments to take. The offset cannot be zero"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns:"})," A list of datetime.date objects"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>o});var i=n(96540);const s={},r=i.createContext(s);function d(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);