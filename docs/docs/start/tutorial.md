# Tutorial (~30 minutes)

This step-by-step tutorial will walk you through creating your own Squirrels project! 

We will start by running the [sqrl new] command to quickly create a working Squirrels project, and then alter it to create a different Squirrels project for weather analytics. Once you've completed the tutorial, you will understand many of the key features of Squirrels!

## Step 1: Bootstrapping a new project

Create a new folder for your project, and open it up in your favourite coding editor (such as VSCode). The name of the folder is your choice (one example is `squirrels-tutorial`).

Follow instructions for [Installation](./install) and [Create a new project](./new-project) to quickly get a sample working project going. 

Then, in the [.env] file, set the `SQRL_SECRET__ADMIN_PASSWORD` environment variable to something of your choice (it is randomly generated by default).

## Step 2: Add the weather database

Now is a good time to add the SQLite database we will use for the rest of the tutorial. Simply run:

```bash
sqrl get-file weather.db
```

This adds a `weather.db` file in the `assets` folder. Feel free to remove the other files in the `assets` folder.

Note that this is mainly done for tutorial purposes. For most production use cases, you would simply specify the database connection string (more details on this soon) and not bring a copy of the database into your project.

## Step 3: Configure the [squirrels.yml] file

Open the [squirrels.yml] file. This is the project configuration file that exists for all Squirrels projects, and it is used to configure many properties of the Squirrels project in [yaml].

In this step, we will focus on the **project_variables**, **connections**, and **datasets** sections.

### Setting the project variables

The project variables **name** and **major_version** are required. The **label** and **description** are optional. You are also free to add any of your own project variables here.

In this tutorial, we will be making datasets for historical weather data (for an undisclosed location). Change the **name** to `weather`, **label** to `Weather Analytics`, and provide a description. We will leave **major_version** as is.

The **project_variables** section should now look like this:

```yaml
project_variables:
  name: weather
  label: Weather Analytics
  description: Analyze weather statistics from 2012 to 2015.
  major_version: 1
```

### Setting the database connections

The **connections** section is where we set all the database connection details that we need. We provide a list of connection names here and refer to them in other files. The connection name `default` must be provided for models that don't specify a connection name explicitly.

Under `default`, change the uri field to `sqlite:///{project_path}/assets/weather.db`. Change the label to "SQLite Weather Database".

:::info

You can also substitute environment variables defined in the [.env] file using [Jinja]. For instance, if there is an environment variable called "SQLITE_CONN_STR" in [.env], then you can also set the url to: 

```
{{ env_vars.SQLITE_CONN_STR }}
```

:::

The **connections** section should now look like this:

```yaml
connections:
  - name: default
    label: SQLite Weather Database
    type: sqlalchemy
    uri: sqlite:///{project_path}/assets/weather.db
```

### Defining the datasets

The **datasets** section is where we define the attributes for all datasets created by the Squirrels project. Every dataset defined will have their own "parameters API" and "dataset result API".

Currently, you may see two datasets configured. We will only have one dataset for this tutorial.

Change the **datasets** section to look like the following instead:

```yaml
datasets:
  - name: weather_by_period
    label: Weather by Time of Year
    description: Gather weather statistics (precipitation, temperature, wind speed, etc.) by time of year or condition
    model: fdr_weather_by_period
    parameters:
      - group_by_dim
```

The model field is the name of the target data model that we will create later. We will create the "group_by_dim" parameter that this dataset uses in the next step.

## Step 4: Create the dataset parameters

Go into the `pyconfigs/parameters.py` file. This file contains the definitions of all the widget parameters used in the dataset through a **main** function. 

We will rewrite this file. Remove all the existing code in the **main** function body such that the file starts off like this:

```python
from squirrels import ParametersArgs, parameters as p, parameter_options as po, data_sources as ds

def main(sqrl: ParametersArgs) -> None:
    # TBA
```

We will create a single-select parameter to specify the dimension to group by.

### Define the parameter options

We first need to specify the list of parameter options. Inside the **main** function, specify the list of options as such:

```python
group_by_options = [
    po.SelectParameterOption('year', 'Year', dim_col='year'),
    po.SelectParameterOption('quarter', 'Quarter', dim_col='quarter'),
    po.SelectParameterOption('month', 'Month', dim_col='month_name', order_by_col='month_order'),
    po.SelectParameterOption('day', 'Day of Year', dim_col='day_of_year'),
    po.SelectParameterOption('cond', 'Condition', dim_col='condition')
]
```

The first two parameters to the **SelectParameterOption** constructors are the ID and label. The ID must be distinct across options and should never change in the future. If an API client associates ID "day" to mean "the dataset will be grouped by day of year", then the ID must always stay as "day" such that this association would never be broken... even if the label of the option changes to "Day Index of Year" in the future.

Arbitrary keyword arguments such as "dim_col" and "order_by_col" can be specified to the **SelectParameterOption** constructor, which will be treated as custom fields to the parameter option. For more info, see the [Widget Parameters] page.

:::info

The **SelectParameterOption** class has an "is_default" attribute to specify the parameter option(s) that are selected by default. By default, "is_default" is set to False. When none of the parameter options have "is_default" set as True, the first option is selected by default for single-select parameters, and nothing is selected by default for multi-select parameters.

:::

### Define the parameters

Create a single-select parameter with the parameter options defined above:

```python
p.SingleSelectParameter.CreateSimple("group_by_dim", "Group By", group_by_options)
```

This sets the name and label of the new parameter to "group_by_dim" and "Group By".

:::info

The possible widget parameter types supported today are **SingleSelectParameter**, **MultiSelectParameter**, **DateParameter**, **DateRangeParameter**, **NumberParameter**, **NumberRangeParameter**, and **TextParameter**. Each parameter type can be created with one of the following factory methods: **CreateSimple**, **CreateWithOptions**, or **CreateFromSource**. Every factory method takes "name" and "label" as required arguments.

For **SingleSelectParameter**, the arguments for **CreateSimple** and **CreateWithOptions** are similar. The difference is that **CreateWithOptions** lets you specify a parent parameter for cascading the shown options. For non-select parameter types like **DateParameter**, there are more differences. Details can be found in the [Widget Parameters] page.

:::

At this point, your [parameters.py] file should look something like this:

```python
from squirrels import ParametersArgs, parameters as p, parameter_options as po, data_sources as ds

def main(sqrl: ParametersArgs) -> None:
    group_by_options = [
        po.SelectParameterOption('year', 'Year', dim_col='year'),
        po.SelectParameterOption('quarter', 'Quarter', dim_col='quarter'),
        po.SelectParameterOption('month', 'Month', dim_col='month_name', order_by_col='month_order'),
        po.SelectParameterOption('day', 'Day of Year', dim_col='day_of_year'),
        po.SelectParameterOption('cond', 'Condition', dim_col='condition')
    ]
    p.SingleSelectParameter.CreateSimple("group_by_dim", "Group By", group_by_options)
```

## Step 5: Create the context file

The context file is a Python file that runs in real-time to transform parameter selections and/or authenticated user attributes into meaningful values that can be used by dynamic data models.

Create a `pyconfigs/context.py` file with the following contents:

```python
from typing import Any
from squirrels import ContextArgs, parameters as p

def main(ctx: dict[str, Any], sqrl: ContextArgs) -> None:
    
    """
    The param_exists method confirms whether the "group_by_dim" parameter exists for the current dataset.
    If it does, we define two context variables called "dim_col" and "order_col".
    """
    if sqrl.param_exists("group_by_dim"):
        group_by_param = sqrl.prms["group_by_dim"]
        assert isinstance(group_by_param, p.SingleSelectParameter)
        
        ctx["dim_col"] = group_by_param.get_selected("dim_col")
        ctx["order_col"] = group_by_param.get_selected("order_by_col", default_field="dim_col")
    
    """
    Define the context variable "role" based on whether the user is authenticated and its attribute(s). See "user.py" for defining user attributes.
    This is shown for demonstration purposes - the "role" context variable will not be used in any data models in this tutorial.
    """
    ctx["role"] = getattr(sqrl.user, "role", "none")
```

In this example, we define context variables "dim_col" and "order_col" based on the "group_by_dim" parameter selection. We also define the "role" context variable based on the authenticated user's attribute(s), which is done for demonstration purposes (the "role" context variable is not used in the rest of this tutorial).

See the [Context Variables] page for more information on the context file.

:::note

The available methods on the parameter object depends on the parameter type. For example, **SingleSelectParameter** objects have a `get_selected` method to get a custom field from the selected option.

By asserting the parameter object is of type **SingleSelectParameter**, it makes it easier to explore the available methods on the parameter through an IDE.

For more information on available methods on different parameter types, see the Python API reference page for the [squirrels.parameters] module.

:::

## Step 6: Create sources

The `models/sources.yml` file lets us document the metadata of sources from our database tables.

The `weather.db` SQLite database we retrieved earlier contains a table called "weather". Replace the [sources.yml] file with the following contents:

```yaml
sources:
  - name: src_weather
    description: Source table for weather metrics by day over time
    connection: default
    table: weather
    load_to_duckdb: true

    columns:
      - name: date
        type: string
        description: The date of the weather statistics in YYYY-MM-DD format
        category: dimension
      
      - name: precipitation
        type: float
        description: The amount of precipitation for the time period in centimeters
        category: measure

      - name: temp_max
        type: float
        description: The maximum temperature for the time period in degrees Celsius
        category: measure
      
      - name: temp_min
        type: float
        description: The minimum temperature for the time period in degrees Celsius
        category: measure
      
      - name: wind
        type: float
        description: The average wind speed for the time period in km/h
        category: measure
      
      - name: condition
        type: string
        description: The weather condition of the time period (e.g. "sun", "fog", "rain")
        category: dimension
```

See the [Sources] page for more information on creating sources.

## Step 7: Create seeds

Seeds are CSV data files that can be used by other data models. For example, we can create a seed that maps month numbers to month names. 

Create a file named `seed_month_names.csv` in the `seeds/` folder with the following contents. Feel free to remove the other files in the `seeds/` folder.

```csv
month_order,month_name
1,January
2,February
3,March
4,April
5,May
6,June
7,July
8,August
9,September
10,October
11,November
12,December
```

In addition, create a `seeds/seed_month_names.yml` file to add metadata for the seed.

```yaml
description: Month number to month name mapping

cast_column_types: false

columns:
  - name: month_order
    type: integer
    description: The month number
    category: dimension
  
  - name: month_name
    type: string
    description: The human-readable month name
    category: dimension
```

Information in the yaml file may be useful for the Squirrels framework as well. See the [Seeds] page for more information on working with seeds.

## Step 8: Create data models from SQL queries

For data models that are created by code, the Squirrels framework supports:
- Creating build models (tables/views to be built offline) from SQL (DuckDB dialect) or Python files
- Creating dbview models (queries that run on an external database in real-time) from SQL files (dialect of the database connection used)
- Creating federate models (queries that run in the API server in real-time) from SQL (DuckDB dialect) or Python files

Sources, seeds, and build models are known as "static data models". 

Dbview models and federate models are known as "dynamic data models".

We have already configured the "source" and "seed" models. For this tutorial, we will create a build model and a federate model with SQL, but will not create any dbview models.

Since we have replaced the source model in [sources.yml], data models that are downstream of the replaced source model will no longer work. 

**Remove the existing files in the `models/builds/`, `models/dbviews/`, and `models/federates/` folders.** Feel free to remove the existing files in the `macros/` folder as well.

### Define a macro

First, create a `macros/metrics.sql` file with the following contents.

```sql
{%- macro get_metrics() -%}
    CAST(SUM(precipitation) AS DECIMAL(6, 1)) AS precipitation,
    CAST(MAX(temp_max) AS DECIMAL(4, 1)) AS temp_max,
    CAST(MIN(temp_min) AS DECIMAL(4, 1)) AS temp_min,
    CAST(AVG(wind) AS DECIMAL(6, 4)) AS wind
{%- endmacro -%}
```

[Macros] allow us to reuse the same SQL text in multiple places, including across different data models.

### Define the build model

Build models are defined in the `models/builds/` folder.

Create a `models/builds/bds_weather_by_date.sql` file with the following contents.

```sql
WITH
weather_by_date AS (

    SELECT
        date::VARCHAR AS date,
        EXTRACT(YEAR FROM date::DATE)::INT AS year,
        EXTRACT(MONTH FROM date::DATE)::INT AS month_order, 
        EXTRACT(DOY FROM date::DATE)::INT AS day_of_year,
        'Q' || CEIL(EXTRACT(MONTH FROM date::DATE) / 3)::INT AS quarter,
        MODE(condition)::VARCHAR AS condition,
        {{ get_metrics() | indent(4) }}
    
    FROM {{ ref("src_weather") }}
    
    GROUP BY date

)
SELECT
    date,
    condition,
    year,
    m.month_order,
    m.month_name,
    day_of_year,
    quarter,
    precipitation,
    temp_max,
    temp_min,
    wind

FROM weather_by_date
    LEFT JOIN {{ ref("seed_month_names") }} AS m USING (month_order)
```

This query finds the total precipitation, max/min temperature, and average wind speed for each date in the source table.

:::info

The SQL file is templated with Jinja. It calls the macros:
- `get_metrics()` which is defined in the `macros/metrics.sql` file we created earlier
- `ref("src_weather")` which references the "src_weather" source we defined earlier

Build models are able to call `ref` on sources (that have `load_to_duckdb: true`), seeds, and other build models.

:::

Let's also add metadata for the build model in the `models/builds/bds_weather_by_date.yml` file.

```yaml
description: |
  This build model aggregates weather data by date and adds additional time-based attributes.

materialization: TABLE  # one of "TABLE" or "VIEW" - defaults to "VIEW" for SQL models if not specified

depends_on:
  - src_weather
  - seed_month_names

columns:
  - name: date
    depends_on:
      - src_weather.date
    pass_through: true

  - name: year
    type: integer
    description: The year extracted from the date
    category: dimension
    depends_on:
      - src_weather.date

  - name: month_order
    type: integer
    description: The order of the month
    category: dimension
    depends_on:
      - src_weather.date
      - seed_month_names.month_order

  - name: month_name
    type: string
    description: The name of the month
    category: dimension
    depends_on:
      - src_weather.date
      - seed_month_names.month_name

  - name: day_of_year
    type: integer
    description: The day of the year (1-366)
    category: dimension
    depends_on:
      - src_weather.date

  - name: quarter
    type: string
    description: The quarter (Q1, Q2, Q3, or Q4) derived from the month
    category: dimension
    depends_on:
      - src_weather.date

  - name: condition
    type: string
    description: The most common weather condition of the date
    category: dimension
    depends_on:
      - src_weather.condition

  - name: precipitation
    type: decimal
    description: Total precipitation of the date in centimeters, rounded to 1 decimal place
    category: measure
    depends_on:
      - src_weather.precipitation

  - name: temp_max
    type: decimal
    description: Maximum temperature of the date in degrees Celsius, rounded to 1 decimal place
    category: measure
    depends_on:
      - src_weather.temp_max

  - name: temp_min
    type: decimal
    description: Minimum temperature of the date in degrees Celsius, rounded to 1 decimal place
    category: measure
    depends_on:
      - src_weather.temp_min

  - name: wind
    type: decimal
    description: Average wind speed of the date in km/h, rounded to 4 decimal places
    category: measure
    depends_on:
      - src_weather.wind
```

For more information on build models, see the [Build Models] page.

### Define the federate model

Federate models are defined in the `models/federates/` folder.

Create a `models/federates/fdr_weather_by_period.sql` file with the following contents.

```sql
WITH
cte_weather_grouped AS (

    SELECT
        {{ ctx.dim_col }} AS dim_value,
        {{ ctx.order_col }} AS ordering,
        {{ get_metrics() | indent(4) }}

    FROM {{ ref("bds_weather_by_date") }}

    GROUP BY dim_value, ordering

)
SELECT
    '{{ ctx.dim_col }}' AS dimension_type,
    dim_value AS dimension_value,
    precipitation,
    temp_max AS temperature_max,
    temp_min AS temperature_min,
    wind

FROM cte_weather_grouped

ORDER BY ordering
```

This query finds the total precipitation, max/min temperature, and average wind speed for each group based on the "Group By" parameter selection in real-time.

:::info

The `{{ ctx.dim_col }}` and `{{ ctx.order_col }}` variables are used to reference the context variables defined in the [context.py] file.

Just like the build model, we use the `get_metrics` macro again. We also use the `ref` macro to reference the build model created earlier.

Federate models are able to call the `ref` macro on sources (that have `load_to_duckdb: true`), seeds, build models, dbview models, and other federate models.

:::

Also, create the `models/federates/fdr_weather_by_period.yml` file to add metadata for the federate model.

```yaml
description: |
  This model aggregates weather data by time of year or condition to show weather statistics.

depends_on:
  - bds_weather_by_date

columns:
  - name: dimension_type
    type: string
    description: The type of dimension (e.g. "year", "month", "condition")
    category: dimension
  
  - name: dimension_value
    type: string
    description: The value of the dimension (e.g. "2020", "January", "sun")
    category: dimension

  - name: precipitation
    type: decimal
    description: Total precipitation of the time period or condition in centimeters, rounded to 1 decimal place
    category: measure
    depends_on:
      - bds_weather_by_date.precipitation

  - name: temperature_max
    type: decimal
    description: Maximum temperature of the time period or condition in degrees Celsius, rounded to 1 decimal place
    category: measure
    depends_on:
      - bds_weather_by_date.temp_max

  - name: temperature_min
    type: decimal
    description: Minimum temperature of the time period or condition in degrees Celsius, rounded to 1 decimal place
    category: measure
    depends_on:
      - bds_weather_by_date.temp_min

  - name: wind
    type: decimal
    description: Average wind speed of the time period or condition in km/h, rounded to 4 decimal places
    category: measure
    depends_on:
      - bds_weather_by_date.wind
```

For more information on federate models, see the [Federate Models] page.

:::info

For SQL models that use the `ref` macro, the `depends_on` field is optional. However, it is required for Python models, and it is recommended to specify it for SQL models as well.

:::

:::note

Similar to federate models, dbview models are also run in real-time and can change behaviour based on parameter selections or authenticated user.

The main difference is that dbview models run on an external database (instead of the API server), and can only reference sources that share the same database connection.

See the [Dbview Models] page for more information on dbview models.

:::

## Step 9: Development testing

You can build the static data models and run the API server by running:

```bash
sqrl run --build
```

See [Running the project](./run-project) for more information on exploring the project in Squirrels Studio.

### Compiling SQL queries

:::note

Currently, this feature is only available for compiling dbview and federate models. Support for compiling build models will be added in a future release.

:::

In practice, you may wish to review what the compiled SQL queries look like (for some set of parameter selections) before actually running the queries.

Run the following to compile the queries for the `weather_by_period` dataset using the default parameter selections:

```bash
sqrl compile --dataset weather_by_period
```

This creates the folder path `target/compile/weather_by_period/default` with the compiled SQL queries for all the relevant SQL models (without actually running them).

:::tip

You can also use `-d` instead of `--dataset`. You may also use `-D` or `--all-datasets` to compile for all datasets.

:::

If you only care about compiling one model, you can run:

```bash
sqrl compile --dataset weather_by_period --select fdr_weather_by_period
```

In addition to writing the file in the `target` folder, this will print out the compiled SQL query for the `fdr_weather_by_period` model as well.

:::tip

You can also use `-s` instead of `--select`. You can choose to run the SQL query with the `--runquery` or `-r` option. When used in conjunction with `-s` or `--select`, this will compile and run all the upstream models as well. You can find the run results as csv files in the `target` folder.

:::

### Using selection test sets

To test on non-default parameter selections, you would define and use test sets. Suppose you want to group by month instead of grouping by year (the default parameter selection).

In the [squirrels.yml] file, replace the **selection_test_sets** section with:

```yaml
selection_test_sets:
  - name: group_by_month
    datasets:
      - weather_by_period
    parameters:
      group_by_dim: 'month'
```

The "datasets" field defines the list of datasets that this test set can be applied to, and the "parameters" field defines parameter selections. The selected value for "group_by_dim" ("month"), which is the ID for the option labeled "Month" in the [parameters.py] file. You can use the `--test-set` or `-t` option to specify the test set to compile with:

```bash
sqrl compile --dataset weather_by_period --test-set group_by_month
```

This creates new files in the `target/compile/weather_by_period/group_by_month` folder (not the "target/compile/weather_by_period/**default**" folder we were looking at before).

See `sqrl compile --help` or the [sqrl compile] page for more details. 

## Step 10: Create a dashboard (optional)

With Squirrels, you can use any Python visualization library (that can produce visualizations in png and/or html format) together with the widget parameters and datasets configured in your Squirrels project to create interactive dashboards.

Dashboards are created in the `dashboards` folder with a Python file and a YAML file. You can retrieve sample dashboard code by running:

```bash
sqrl get-file dashboard_example
```

This will add the `dashboards/dashboard_example.py` and `dashboards/dashboard_example.yml` files to your project. Currently, these sample dashboards do not work since they depend on datasets that no longer exist in the project.

For a working example, replace the `dashboards/dashboard_example.py` file with the following code:

```python
from squirrels import DashboardArgs, dashboards as d
from matplotlib import pyplot as plt, figure as f, axes as a

async def main(sqrl: DashboardArgs) -> d.PngDashboard:
    weather_by_group = await sqrl.dataset("weather_by_period")
    weather_by_condition = await sqrl.dataset("weather_by_period", fixed_parameters={"group_by_dim": "cond"})

    # Create a figure with two subplots
    fig, (ax0, ax1) = plt.subplots(2, 1, figsize=(8, 8), height_ratios=(1, 2))
    fig: f.Figure; ax0: a.Axes; ax1: a.Axes
    fig.tight_layout(pad=4, h_pad=6)

    # Create a line chart of weather by group

    # Plot temperature min and max
    ax0.plot(weather_by_group["dimension_value"], weather_by_group["temperature_max"], color='darkorange', label="Max Temperature")
    ax0.plot(weather_by_group["dimension_value"], weather_by_group["temperature_min"], color='blue', label="Min Temperature")
    ax0.set_xlabel(weather_by_group["dimension_type"][0])  # Use the first value as label
    ax0.set_ylabel("Temperature (°C)")
    ax0.legend()

    # Create a bar chart of temperature by condition

    # Plot precipitation by condition
    ax1.bar(weather_by_condition["dimension_value"], weather_by_condition["temperature_max"], color='darkorange', label="Max Temperature")
    ax1.bar(weather_by_condition["dimension_value"], weather_by_condition["temperature_min"], color='blue', label="Min Temperature")
    ax1.set_xlabel("Weather Condition")
    ax1.set_ylabel("Temperature (°C)")
    ax1.legend()

    # Rotate x-axis labels for better readability
    plt.setp(ax0.get_xticklabels(), rotation=45, ha="right")
    plt.setp(ax1.get_xticklabels(), rotation=45, ha="right")
    
    return d.PngDashboard(fig)
```

And replace the `dashboards/dashboard_example.yml` file with the following contents:

```yaml
label: Dashboard Example

description: This is an example dashboard

scope: public

format: png

parameters:
  - group_by_dim

depends_on:
  - name: weather_by_group
    dataset: weather_by_period
  
  - name: weather_by_condition
    dataset: weather_by_period
    fixed_parameters:
      - group_by_dim: cond (Condition)
```

Now, you should be able to see API docs for dashboard API endpoints, or explore the dashboard in Squirrels Studio.

See the [Dashboards] page for more information on creating dashboards.

:::note

You must reactivate the API server the test out the new changes. Since there were no changes to the static data models you can simply run `sqrl run` instead of `sqrl run --build`.

:::

**Congratulations, you have reached the end of the tutorial!**

## What's next?

For a more complex version of a weather analytics project, see the "sqrl-weather-analytics" folder in our "squirrels-examples" github repo here:

https://github.com/squirrels-analytics/squirrels-examples/tree/main/sqrl-weather-analytics

This is a revised example that demonstrates:
- Querying multiple database systems with dbview models and joining the results together in a single dataset / API endpoint
- Using a Python data model that loads a machine learning (ML) model to create a column for ML model predictions

In addition, the following topics may also useful for your Squirrels projects:
- [User Model](../concepts/user) - Configure custom user attributes and use them to control behaviour of data models
- [Context Variables & Placeholders](../concepts/context) - We briefly touched on context variables in this tutorial, but not placeholders
- [Date Utils](../concepts/dateutils) - Use the `date_utils` module to apply a series of date transformations to parameter selections
- [Deploy with Docker](../guides/deploy) - Deploy your Squirrels project with Docker

You can also check out the [CLI References] to understand the commands available with Squirrels, or check out the [Python APIs] available in the Squirrels library.


[python virtual environments]: https://realpython.com/python-virtual-environments-a-primer/
[yaml]: https://yaml.org/
[Jinja]: https://jinja.palletsprojects.com/
[sqlalchemy database URLs]: https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls
[sqrl new]: ../../references/cli/new
[sqrl compile]: ../../references/cli/compile
[squirrels.yml]: ../concepts/squirrels-yml
[.env]: ../concepts/environment
[parameters.py]: ../concepts/parameters
[context.py]: ../concepts/context
[sources.yml]: ../concepts/models-source
[seeds]: ../concepts/models-seed
[Database Connections]: ../concepts/connections
[Widget Parameters]: ../concepts/parameters
[Context Variables]: ../concepts/context
[Macros]: ../concepts/macros
[Sources]: ../concepts/models-source
[Seeds]: ../concepts/models-seed
[Build Models]: ../concepts/models-build
[Federate Models]: ../concepts/models-federate
[Dbview Models]: ../concepts/models-dbview
[Dashboards]: ../concepts/dashboards
[CLI References]: ../../references/cli
[Python APIs]: ../../references/python
[squirrels.parameters]: ../../tba
